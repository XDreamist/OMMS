import * as TSModule from 'typescript';
import { has, get, set, del } from 'object-path';
import { dirname } from 'path';
import { JSDOM } from 'jsdom';
import { __rest, __decorate, __param } from 'tslib';
import chalk from 'chalk';
import { inspect } from 'util';

/**
 * Returns true if the provided value is ObjectLike
 *
 * @param value
 * @returns
 */
function isObjectLike(value) {
    return value != null && (typeof value === "function" || typeof value === "object");
}
/**
 * Returns true if the given value can be observed
 *
 * @param value
 * @returns
 */
function canBeObserved(value) {
    return isObjectLike(value);
}

/**
 * Returns true if the given function is either Function.prototype.bind, Function.prototype.call, or Function.prototype.apply
 *
 * @param func
 * @param [environment]
 * @return
 */
function isBindCallApply(func, environment) {
    switch (func) {
        case Function.prototype.bind:
        case Function.prototype.call:
        case Function.prototype.apply:
            return true;
    }
    if (environment != null) {
        const _Function = getFromLexicalEnvironment(undefined, environment, "Function").literal;
        switch (func) {
            case _Function.prototype.bind:
            case _Function.prototype.call:
            case _Function.prototype.apply:
                return true;
        }
    }
    return false;
}

/* eslint-disable @typescript-eslint/ban-types */
/**
 * Stringifies the given PropertyKey path
 */
function stringifyPath(path) {
    return path.map(part => (typeof part === "symbol" ? part.description : part)).join(".");
}
/**
 * Creates a proxy with hooks to check the given policy
 */
function createPolicyProxy({ hook, item, scope, policy }) {
    /**
     * Creates a trap that captures function invocation
     */
    function createAccessTrap(inputPath, currentItem) {
        return !canBeObserved(currentItem) || isBindCallApply(currentItem)
            ? currentItem
            : new Proxy(currentItem, {
                /**
                 * Constructs a new instance of the given target
                 */
                construct(target, argArray, newTarget) {
                    // Don't proceed if the hook says no
                    if (!hook({
                        kind: "__$$_PROXY_CONSTRUCT" /* CONSTRUCT */,
                        policy,
                        newTarget,
                        argArray,
                        target,
                        path: stringifyPath(inputPath)
                    })) {
                        return {};
                    }
                    return Reflect.construct(target, argArray, newTarget);
                },
                /**
                 * A trap for a function call. Used to create new proxies for methods on the retrieved module objects
                 */
                apply(target, thisArg, argArray = []) {
                    // Don't proceed if the hook says no
                    if (!hook({
                        kind: "__$$_PROXY_APPLY" /* APPLY */,
                        policy,
                        thisArg,
                        argArray,
                        target,
                        path: stringifyPath(inputPath)
                    })) {
                        return;
                    }
                    return Reflect.apply(target, thisArg, argArray);
                },
                /**
                 * Gets a trap for 'get' accesses
                 */
                get(target, property, receiver) {
                    const newPath = [...inputPath, property];
                    // Don't proceed if the hook says no
                    if (!hook({
                        kind: "__$$_PROXY_GET" /* GET */,
                        policy,
                        path: stringifyPath(newPath),
                        target
                    })) {
                        return;
                    }
                    const match = Reflect.get(target, property, receiver);
                    const config = Reflect.getOwnPropertyDescriptor(currentItem, property);
                    if (config != null && config.configurable === false && config.writable === false) {
                        return currentItem[property];
                    }
                    return createAccessTrap(newPath, match);
                }
            });
    }
    return !canBeObserved(item) ? item : createAccessTrap([scope], item);
}

/**
 * Stringifies the given PolicyTrapKind on the given path
 *
 * @param kind
 * @param path
 * @return
 */
function stringifyPolicyTrapKindOnPath(kind, path) {
    switch (kind) {
        case "__$$_PROXY_GET" /* GET */:
            return `get ${path}`;
        case "__$$_PROXY_APPLY" /* APPLY */:
            return `${path}(...)`;
        case "__$$_PROXY_CONSTRUCT" /* CONSTRUCT */:
            return `new ${path}(...)`;
    }
}

/**
 * A Map between built-in modules and the kind of IO operations their members performs
 * @type {TrapConditionMap<NodeBuiltInsAndGlobals>}
 */
const NETWORK_MAP = {
    http2: {
        connect: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        createSecureServer: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        createServer: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        }
    },
    https: {
        createServer: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        request: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        get: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        Server: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        },
        globalAgent: {
            destroy: {
                ["__$$_PROXY_APPLY" /* APPLY */]: true
            }
        },
        Agent: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        }
    },
    http: {
        createServer: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        request: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        get: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        Server: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        },
        ClientRequest: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        },
        globalAgent: {
            destroy: {
                ["__$$_PROXY_APPLY" /* APPLY */]: true
            }
        },
        Agent: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        }
    },
    dgram: {
        createSocket: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        }
    },
    dns: {
        lookup: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        lookupService: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolve: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolve4: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolve6: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolveAny: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolveCname: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolveMx: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolveNaptr: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolveNs: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolvePtr: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolveSoa: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolveSrv: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolveTxt: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        reverse: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        Resolver: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        }
    },
    net: {
        createServer: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        createConnection: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        connect: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        Server: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        }
    },
    tls: {
        createServer: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        createSecureContext: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        connect: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        Server: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        },
        TLSSocket: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        }
    }
};

/**
 * A Map between built-in identifiers and the members that produce non-deterministic results.
 * @type {TrapConditionMap<NodeBuiltInsAndGlobals>}
 */
const NONDETERMINISTIC_MAP = Object.assign(Object.assign({}, NETWORK_MAP), { Math: {
        random: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        }
    }, Date: {
        now: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        // Dates that receive no arguments are nondeterministic since they care about "now" and will evaluate to a new value for each invocation
        ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: (...args) => args.length === 0 && !(args[0] instanceof Date)
    } });

/**
 * Returns true if the given item is a TrapCondition
 *
 * @param item
 * @param condition
 * @return
 */
function isTrapCondition(item, condition) {
    // noinspection SuspiciousTypeOfGuard
    return typeof item === typeof condition || typeof item === "function";
}
/**
 * Returns true if the given item is a TrapCondition
 *
 * @param item
 * @return
 */
function isTrapConditionFunction(item) {
    return typeof item === "function";
}

/* eslint-disable @typescript-eslint/ban-types */
/**
 * Returns true if the given path represents something that is nondeterministic.
 *
 * @param map
 * @param condition
 * @param item
 * @returns
 */
function isTrapConditionMet(map, condition, item) {
    const atoms = item.path.split(".");
    return walkAtoms(map, condition, item, atoms);
}
/**
 * Walks all atoms of the given item path
 *
 * @param map
 * @param matchCondition
 * @param item
 * @param atoms
 * @return
 */
function walkAtoms(map, matchCondition, item, atoms) {
    const [head, ...tail] = atoms;
    if (head == null)
        return false;
    const mapEntry = map[head];
    // If nothing was matched within the namespace, the trap wasn't matched
    if (mapEntry == null)
        return false;
    if (isTrapCondition(mapEntry, matchCondition)) {
        return handleTrapCondition(mapEntry, matchCondition, item);
    }
    else {
        const trapMapMatch = mapEntry[item.kind];
        if (trapMapMatch != null) {
            return handleTrapCondition(trapMapMatch, matchCondition, item);
        }
        else {
            return walkAtoms(mapEntry, matchCondition, item, tail);
        }
    }
}
/**
 * Handles a TrapCondition
 *
 * @param trapCondition
 * @param matchCondition
 * @param item
 * @return
 */
function handleTrapCondition(trapCondition, matchCondition, item) {
    // If matching the condition depends on the provided arguments, pass them in
    if (isTrapConditionFunction(trapCondition)) {
        const castItem = item;
        return trapCondition(...castItem.argArray) === matchCondition;
    }
    // Otherwise, evaluate the truthiness of the condition
    else {
        return trapCondition === matchCondition;
    }
}

/**
 * Returns true if the given path represents something that is nondeterministic.
 *
 * @param item
 * @returns
 */
function isNonDeterministic(item) {
    return isTrapConditionMet(NONDETERMINISTIC_MAP, true, item);
}

/**
 * A Base class for EvaluationErrors
 */
class EvaluationError extends Error {
    constructor({ node, message }) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.node = node;
    }
}

/**
 * An Error that can be thrown when a policy is violated
 */
class PolicyError extends EvaluationError {
    constructor({ violation, node, message }) {
        super({ node, message: `[${violation}]: ${message}` });
        this.violation = violation;
    }
}

/**
 * An Error that can be thrown when something nondeterministic is attempted to be evaluated and has been disallowed to be so
 */
class NonDeterministicError extends PolicyError {
    constructor({ operation, node, message = `The operation: '${operation}' is nondeterministic. That is in violation of the policy` }) {
        super({ violation: "deterministic", message, node });
        this.operation = operation;
    }
}

/**
 * A Map between built-in modules and the kind of IO operations their members performs
 * @type {TrapConditionMap<NodeBuiltInsAndGlobals, "read"|"write">}
 */
const IO_MAP = {
    fs: {
        readFile: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        readFileSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        readdir: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        readdirSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        read: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        readSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        exists: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        existsSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        access: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        accessSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        close: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        closeSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        createReadStream: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        stat: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        statSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        watch: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        watchFile: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        unwatchFile: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        realpath: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        realpathSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        fstat: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        fstatSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        createWriteStream: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        copyFile: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        copyFileSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        unlink: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        unlinkSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        rmdir: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        rmdirSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        symlink: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        symlinkSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        truncate: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        truncateSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        utimes: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        utimesSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        appendFile: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        appendFileSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        write: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        writeSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        writeFile: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        writeFileSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        chmod: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        chmodSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        chown: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        chownSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        mkdir: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        mkdirSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        rename: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        renameSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        futimes: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        futimesSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        link: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        linkSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        mkdtemp: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        open: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        openSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        fchmod: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        fchmodSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        fchown: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        fchownSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        ftruncate: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        ftruncateSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        fsync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        fsyncSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        fdatasync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        fdatasyncSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        lchmod: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        lchmodSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        }
    }
};

/**
 * Returns true if the given member represents a READ operation from IO
 *
 * @param item
 * @returns
 */
function isIoRead(item) {
    return isTrapConditionMet(IO_MAP, "read", item);
}

/**
 * An Error that can be thrown when an IO operation is attempted to be executed that is in violation of the context policy
 */
class IoError extends PolicyError {
    constructor({ node, kind, message = `${kind} operations are in violation of the policy` }) {
        super({ violation: "io", message, node });
        this.kind = kind;
    }
}

/**
 * Returns true if the given member represents a WRITE operation from IO
 *
 * @param item
 * @returns
 */
function isIoWrite(item) {
    return isTrapConditionMet(IO_MAP, "write", item);
}

/**
 * Returns true if the given item represents a network operation
 *
 * @param item
 * @returns
 */
function isNetworkOperation(item) {
    return isTrapConditionMet(NETWORK_MAP, true, item);
}

/**
 * An Error that can be thrown when a network operation is attempted to be executed that is in violation of the context policy
 */
class NetworkError extends PolicyError {
    constructor({ operation, node, message = `The operation: '${operation}' is performing network activity. That is in violation of the policy` }) {
        super({ violation: "deterministic", message, node });
        this.operation = operation;
    }
}

/**
 * A Map between built-in modules (as well as 'process' and the kind of IO operations their members performs
 * @type {TrapConditionMap<NodeBuiltInsAndGlobals, string>}
 */
const PROCESS_MAP = {
    process: {
        exit: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "exit"
        }
    },
    // Everything inside child_process is just one big violation of this policy
    child_process: {
        ["__$$_PROXY_APPLY" /* APPLY */]: "spawnChild"
    },
    cluster: {
        fork: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "spawnChild"
        },
        worker: {
            ["__$$_PROXY_GET" /* GET */]: "spawnChild"
        },
        Worker: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: "spawnChild"
        },
        workers: {
            ["__$$_PROXY_GET" /* GET */]: "spawnChild"
        }
    }
};

/**
 * Returns true if the given item represents a process operation that exits the process
 *
 * @param item
 * @returns
 */
function isProcessExitOperation(item) {
    return isTrapConditionMet(PROCESS_MAP, "exit", item);
}

/**
 * An Error that can be thrown when a Process operation is attempted to be executed that is in violation of the context policy
 */
class ProcessError extends PolicyError {
    constructor({ kind, node, message = `${kind} operations are in violation of the policy` }) {
        super({ violation: "process", message, node });
        this.kind = kind;
    }
}

/**
 * Returns true if the given item represents a process operation that spawns a child
 *
 * @param item
 * @returns
 */
function isProcessSpawnChildOperation(item) {
    return isTrapConditionMet(PROCESS_MAP, "spawnChild", item);
}

/**
 * A Map between built-in modules (as well as 'console' and the operations that print to console
 * @type {TrapConditionMap<NodeBuiltInsAndGlobals>}
 */
const CONSOLE_MAP = {
    console: {
        ["__$$_PROXY_APPLY" /* APPLY */]: true
    }
};

/**
 * Returns true if the given item represents an operation that prints to console
 *
 * @param item
 * @returns
 */
function isConsoleOperation(item) {
    return isTrapConditionMet(CONSOLE_MAP, true, item);
}

/**
 * Creates an environment that provide hooks into policy checks
 */
function createSanitizedEnvironment({ policy, env, getCurrentNode }) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const hook = (item) => {
        if (!policy.console && isConsoleOperation(item)) {
            return false;
        }
        if (!policy.io.read && isIoRead(item)) {
            throw new IoError({ kind: "read", node: getCurrentNode() });
        }
        if (!policy.io.write && isIoWrite(item)) {
            throw new IoError({ kind: "write", node: getCurrentNode() });
        }
        if (!policy.process.exit && isProcessExitOperation(item)) {
            throw new ProcessError({ kind: "exit", node: getCurrentNode() });
        }
        if (!policy.process.exit && isProcessSpawnChildOperation(item)) {
            throw new ProcessError({ kind: "spawnChild", node: getCurrentNode() });
        }
        if (!policy.network && isNetworkOperation(item)) {
            throw new NetworkError({ operation: stringifyPolicyTrapKindOnPath(item.kind, item.path), node: getCurrentNode() });
        }
        if (policy.deterministic && isNonDeterministic(item)) {
            throw new NonDeterministicError({ operation: stringifyPolicyTrapKindOnPath(item.kind, item.path), node: getCurrentNode() });
        }
        return true;
    };
    const descriptors = Object.entries(Object.getOwnPropertyDescriptors(env));
    const gettersAndSetters = Object.assign({}, ...descriptors.filter(([, descriptor]) => !("value" in descriptor)).map(([name, descriptor]) => ({ [name]: descriptor })));
    const values = Object.assign({}, ...descriptors
        .filter(([, descriptor]) => "value" in descriptor)
        .map(([name, descriptor]) => ({
        [name]: name === "require"
            ? new Proxy(descriptor.value, {
                /**
                 * A trap for a function call. Used to create new proxies for methods on the retrieved module objects
                 *
                 * @param target
                 * @param thisArg
                 * @param argArray
                 * @return
                 */
                apply(target, thisArg, argArray = []) {
                    const [moduleName] = argArray;
                    return createPolicyProxy({
                        policy,
                        item: Reflect.apply(target, thisArg, argArray),
                        scope: moduleName,
                        hook
                    });
                }
            })
            : createPolicyProxy({
                policy,
                item: descriptor.value,
                scope: name,
                hook
            })
    })));
    return Object.defineProperties(values, Object.assign({}, gettersAndSetters));
}

const ECMA_GLOBALS = () => {
    /* eslint-disable @typescript-eslint/naming-convention */
    const base = {
        Infinity,
        NaN,
        undefined,
        isNaN,
        parseFloat,
        parseInt,
        decodeURI,
        decodeURIComponent,
        encodeURI,
        encodeURIComponent,
        Array,
        Boolean,
        Date,
        Error,
        EvalError,
        Number,
        Object,
        RangeError,
        ReferenceError,
        RegExp,
        String,
        SyntaxError,
        TypeError,
        URIError,
        JSON,
        Math,
        escape,
        unescape,
        // eslint-disable-next-line no-eval
        eval,
        Function
        /* eslint-enable @typescript-eslint/naming-convention */
    };
    try {
        base.BigInt = BigInt;
    }
    catch (_a) { }
    try {
        base.Reflect = Reflect;
    }
    catch (_b) { }
    try {
        base.WeakMap = WeakMap;
    }
    catch (_c) { }
    try {
        base.WeakSet = WeakSet;
    }
    catch (_d) { }
    try {
        base.Set = Set;
    }
    catch (_e) { }
    try {
        base.Map = Map;
    }
    catch (_f) { }
    try {
        base.Uint8Array = Uint8Array;
    }
    catch (_g) { }
    try {
        base.Uint8ClampedArray = Uint8ClampedArray;
    }
    catch (_h) { }
    try {
        base.Uint16Array = Uint16Array;
    }
    catch (_j) { }
    try {
        base.Uint32Array = Uint32Array;
    }
    catch (_k) { }
    try {
        base.Intl = Intl;
    }
    catch (_l) { }
    try {
        base.Int8Array = Int8Array;
    }
    catch (_m) { }
    try {
        base.Int16Array = Int16Array;
    }
    catch (_o) { }
    try {
        base.Int32Array = Int32Array;
    }
    catch (_p) { }
    try {
        base.Float32Array = Float32Array;
    }
    catch (_q) { }
    try {
        base.Float64Array = Float64Array;
    }
    catch (_r) { }
    try {
        base.ArrayBuffer = ArrayBuffer;
    }
    catch (_s) { }
    try {
        base.DataView = DataView;
    }
    catch (_t) { }
    try {
        base.isFinite = isFinite;
    }
    catch (_u) { }
    try {
        base.Promise = Promise;
    }
    catch (_v) { }
    try {
        base.Proxy = Proxy;
    }
    catch (_w) { }
    try {
        base.Symbol = Symbol;
    }
    catch (_x) { }
    return base;
};

/* eslint-disable @typescript-eslint/ban-types */
function mergeDescriptors(a, b, c) {
    const newObj = {};
    const normalizedB = b == null ? {} : b;
    const normalizedC = c == null ? {} : c;
    [a, normalizedB, normalizedC].forEach(item => Object.defineProperties(newObj, Object.getOwnPropertyDescriptors(item)));
    return newObj;
}

/* eslint-disable @typescript-eslint/ban-types */
/**
 * Excludes the properties of B from A
 */
function subtract(a, b) {
    const newA = {};
    Object.getOwnPropertyNames(a).forEach(name => {
        if (!(name in b)) {
            Object.defineProperty(newA, name, Object.getOwnPropertyDescriptor(a, name));
        }
    });
    return newA;
}

const NODE_GLOBALS = () => {
    const ecmaGlobals = ECMA_GLOBALS();
    const merged = mergeDescriptors(subtract(global, ecmaGlobals), ecmaGlobals, {
        require,
        __dirname: (fileName) => dirname(fileName),
        __filename: (fileName) => fileName
    });
    Object.defineProperties(merged, {
        global: {
            get() {
                return merged;
            }
        },
        globalThis: {
            get() {
                return merged;
            }
        }
    });
    return merged;
};

var EnvironmentPresetKind;
(function (EnvironmentPresetKind) {
    EnvironmentPresetKind["NONE"] = "NONE";
    EnvironmentPresetKind["ECMA"] = "ECMA";
    EnvironmentPresetKind["BROWSER"] = "BROWSER";
    EnvironmentPresetKind["NODE"] = "NODE";
})(EnvironmentPresetKind || (EnvironmentPresetKind = {}));

/**
 * Returns an object containing the properties that are relevant to 'requestAnimationFrame' and 'requestIdleCallback'
 */
function rafImplementation(global) {
    let lastTime = 0;
    const _requestAnimationFrame = function requestAnimationFrame(callback) {
        const currTime = new Date().getTime();
        const timeToCall = Math.max(0, 16 - (currTime - lastTime));
        const id = global.setTimeout(function () {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
    const _cancelAnimationFrame = function cancelAnimationFrame(id) {
        clearTimeout(id);
    };
    return {
        requestAnimationFrame: _requestAnimationFrame,
        cancelAnimationFrame: _cancelAnimationFrame
    };
}

const BROWSER_GLOBALS = () => {
    const { window } = new JSDOM("", { url: "https://example.com" });
    const ecmaGlobals = ECMA_GLOBALS();
    const raf = rafImplementation(window);
    const merged = mergeDescriptors(subtract(window, ecmaGlobals), subtract(raf, window), ecmaGlobals);
    Object.defineProperties(merged, {
        window: {
            get() {
                return merged;
            }
        },
        globalThis: {
            get() {
                return merged;
            }
        }
    });
    return merged;
};

const RETURN_SYMBOL = "[return]";

const BREAK_SYMBOL = "[break]";

const CONTINUE_SYMBOL = "[continue]";

const THIS_SYMBOL = "this";

const SUPER_SYMBOL = "super";

/**
 * Gets a value from a Lexical Environment
 *
 * @param env
 * @param path
 * @returns
 */
function getRelevantDictFromLexicalEnvironment(env, path) {
    const [firstBinding] = path.split(".");
    if (has(env.env, firstBinding))
        return env.env;
    if (env.parentEnv != null)
        return getRelevantDictFromLexicalEnvironment(env.parentEnv, path);
    return undefined;
}
/**
 * Gets the EnvironmentPresetKind for the given LexicalEnvironment
 */
function getPresetForLexicalEnvironment(env) {
    if (env.preset != null)
        return env.preset;
    else if (env.parentEnv != null)
        return getPresetForLexicalEnvironment(env.parentEnv);
    else
        return EnvironmentPresetKind.NONE;
}
/**
 * Gets a value from a Lexical Environment
 */
function getFromLexicalEnvironment(node, env, path) {
    const [firstBinding] = path.split(".");
    if (has(env.env, firstBinding)) {
        const literal = get(env.env, path);
        switch (path) {
            // If we're in a Node environment, the "__dirname" and "__filename" meta-properties should report the current directory or file of the SourceFile and not the parent process
            case "__dirname":
            case "__filename": {
                const preset = getPresetForLexicalEnvironment(env);
                return preset === EnvironmentPresetKind.NODE && typeof literal === "function" && node != null ? { literal: literal(node.getSourceFile().fileName) } : { literal };
            }
            default:
                return { literal };
        }
    }
    if (env.parentEnv != null)
        return getFromLexicalEnvironment(node, env.parentEnv, path);
    return undefined;
}
/**
 * Returns true if the given lexical environment contains a value on the given path that equals the given literal
 */
function pathInLexicalEnvironmentEquals(node, env, equals, ...matchPaths) {
    return matchPaths.some(path => {
        const match = getFromLexicalEnvironment(node, env, path);
        return match == null ? false : match.literal === equals;
    });
}
/**
 * Returns true if the given value represents an internal symbol
 *
 * @param value
 * @return
 */
function isInternalSymbol(value) {
    switch (value) {
        case RETURN_SYMBOL:
        case BREAK_SYMBOL:
        case CONTINUE_SYMBOL:
        case THIS_SYMBOL:
        case SUPER_SYMBOL:
            return true;
        default:
            return false;
    }
}
/**
 * Gets a value from a Lexical Environment
 *
 * @param options
 * @param [newBinding=false]
 */
function setInLexicalEnvironment({ env, path, value, reporting, node, newBinding = false }) {
    const [firstBinding] = path.split(".");
    if (has(env.env, firstBinding) || newBinding || env.parentEnv == null) {
        // If the value didn't change, do no more
        if (has(env.env, path) && get(env.env, path) === value)
            return;
        // Otherwise, mutate it
        set(env.env, path, value);
        // Inform reporting hooks if any is given
        if (reporting.reportBindings != null && !isInternalSymbol(path)) {
            reporting.reportBindings({ path, value, node });
        }
    }
    else {
        let currentParentEnv = env.parentEnv;
        while (currentParentEnv != null) {
            if (has(currentParentEnv.env, firstBinding)) {
                // If the value didn't change, do no more
                if (has(currentParentEnv.env, path) && get(currentParentEnv.env, path) === value)
                    return;
                // Otherwise, mutate it
                set(currentParentEnv.env, path, value);
                // Inform reporting hooks if any is given
                if (reporting.reportBindings != null && !isInternalSymbol(path)) {
                    reporting.reportBindings({ path, value, node });
                }
                return;
            }
            else {
                currentParentEnv = currentParentEnv.parentEnv;
            }
        }
    }
}
/**
 * Clears a binding from a Lexical Environment
 *
 * @param env
 * @param path
 */
function clearBindingFromLexicalEnvironment(env, path) {
    const [firstBinding] = path.split(".");
    if (has(env.env, firstBinding)) {
        del(env.env, path);
    }
    else {
        let currentParentEnv = env.parentEnv;
        while (currentParentEnv != null) {
            if (has(currentParentEnv.env, firstBinding)) {
                del(currentParentEnv.env, path);
                return;
            }
            else {
                currentParentEnv = currentParentEnv.parentEnv;
            }
        }
    }
}
/**
 * Creates a Lexical Environment
 *
 * @param options
 * @returns
 */
function createLexicalEnvironment({ inputEnvironment: { extra, preset }, policy, getCurrentNode }) {
    let envInput;
    switch (preset) {
        case EnvironmentPresetKind.NONE:
            envInput = mergeDescriptors(extra);
            break;
        case EnvironmentPresetKind.ECMA:
            envInput = mergeDescriptors(ECMA_GLOBALS(), extra);
            break;
        case EnvironmentPresetKind.NODE:
            envInput = mergeDescriptors(NODE_GLOBALS(), extra);
            break;
        case EnvironmentPresetKind.BROWSER:
            envInput = mergeDescriptors(BROWSER_GLOBALS(), extra);
            break;
        default:
            envInput = {};
            break;
    }
    return {
        preset,
        parentEnv: undefined,
        env: createSanitizedEnvironment({
            policy,
            env: envInput,
            getCurrentNode
        })
    };
}

/**
 * Returns true if the given node is a BooleanLiteral
 */
function isBooleanLiteral(node, typescript) {
    return node.kind === typescript.SyntaxKind.TrueKeyword || node.kind === typescript.SyntaxKind.FalseKeyword;
}

/**
 * Returns true if the given node is a NullLiteral
 */
function isNullLiteral(node, typescript) {
    return node.kind === typescript.SyntaxKind.NullKeyword;
}

/**
 * This is a tiny function that avoids the costs of building up an evaluation environment
 * for the interpreter. If the node is a simple literal, it will return its' value.
 */
function evaluateSimpleLiteral(node, typescript) {
    var _a;
    if (typescript.isStringLiteralLike(node))
        return { success: true, value: node.text };
    else if (isBooleanLiteral(node, typescript))
        return { success: true, value: node.kind === typescript.SyntaxKind.TrueKeyword };
    else if (typescript.isRegularExpressionLiteral(node))
        return { success: true, value: new Function(`return ${node.text}`)() };
    else if (typescript.isNumericLiteral(node))
        return { success: true, value: Number(node.text) };
    else if ((_a = typescript.isBigIntLiteral) === null || _a === void 0 ? void 0 : _a.call(typescript, node))
        return { success: true, value: BigInt(node.text) };
    else if (typescript.isIdentifier(node) && node.text === "Infinity")
        return { success: true, value: Infinity };
    else if (typescript.isIdentifier(node) && node.text === "NaN")
        return { success: true, value: NaN };
    else if (typescript.isIdentifier(node) && node.text === "null")
        return { success: true, value: null };
    else if (typescript.isIdentifier(node) && node.text === "undefined")
        return { success: true, value: undefined };
    else if (isNullLiteral(node, typescript))
        return { success: true, value: null };
    else
        return { success: false };
}

/**
 * An Error that can be thrown when the maximum amount of operations dictated by the policy is exceeded
 */
class MaxOpsExceededError extends PolicyError {
    constructor({ ops, node, message = `Maximum ops exceeded: ${ops}` }) {
        super({ violation: "maxOps", message, node });
        this.ops = ops;
    }
}

/**
 * Evaluates, or attempts to evaluate, a VariableDeclaration
 */
function evaluateVariableDeclaration({ node, environment, evaluate, stack, typescript, statementTraversalStack }, initializer) {
    const initializerResult = initializer != null
        ? initializer
        : node.initializer == null
            ? // A VariableDeclaration with no initializer is implicitly bound to 'undefined'
                undefined
            : evaluate.expression(node.initializer, environment, statementTraversalStack);
    // There's no way of destructuring a nullish value
    if (initializerResult == null && !typescript.isIdentifier(node.name)) {
        throw new EvaluationError({ node });
    }
    // Evaluate the binding name
    evaluate.nodeWithArgument(node.name, environment, initializerResult, statementTraversalStack);
    stack.push(initializerResult);
}

/**
 * Returns true if the given node is a ThisExpression
 */
function isThisExpression(node, typescript) {
    return node.kind === typescript.SyntaxKind.ThisKeyword;
}

/**
 * Returns true if the given node is a SuperExpression
 */
function isSuperExpression(node, typescript) {
    return node.kind === typescript.SyntaxKind.SuperKeyword;
}

/**
 * Gets the path to "dot" into an object with based on the node. For example, if the node is a simple identifier, say, 'foo', the dot path is simply "foo".
 * And, if it is a PropertyAccessExpression, that path may be "console.log" for example
 */
function getDotPathFromNode(options) {
    var _a;
    const { node, evaluate, typescript, environment, statementTraversalStack } = options;
    if (typescript.isIdentifier(node)) {
        return node.text;
    }
    else if ((_a = typescript.isPrivateIdentifier) === null || _a === void 0 ? void 0 : _a.call(typescript, node)) {
        return node.text;
    }
    else if (isThisExpression(node, typescript)) {
        return THIS_SYMBOL;
    }
    else if (isSuperExpression(node, typescript)) {
        return SUPER_SYMBOL;
    }
    else if (typescript.isParenthesizedExpression(node)) {
        return getDotPathFromNode(Object.assign(Object.assign({}, options), { node: node.expression }));
    }
    else if (typescript.isTypeAssertion(node)) {
        return getDotPathFromNode(Object.assign(Object.assign({}, options), { node: node.expression }));
    }
    else if (typescript.isPropertyAccessExpression(node)) {
        let leftHand = getDotPathFromNode(Object.assign(Object.assign({}, options), { node: node.expression }));
        if (leftHand == null)
            leftHand = evaluate.expression(node.expression, environment, statementTraversalStack);
        let rightHand = getDotPathFromNode(Object.assign(Object.assign({}, options), { node: node.name }));
        if (rightHand == null)
            rightHand = evaluate.expression(node.name, environment, statementTraversalStack);
        if (leftHand == null || rightHand == null)
            return undefined;
        return `${leftHand}.${rightHand}`;
    }
    else if (typescript.isElementAccessExpression(node)) {
        let leftHand = getDotPathFromNode(Object.assign(Object.assign({}, options), { node: node.expression }));
        if (leftHand == null)
            leftHand = evaluate.expression(node.expression, environment, statementTraversalStack);
        const rightHand = evaluate.expression(node.argumentExpression, environment, statementTraversalStack);
        if (leftHand == null || rightHand == null)
            return undefined;
        return `${leftHand}.${rightHand}`;
    }
    else if (typescript.isFunctionDeclaration(node)) {
        if (node.name == null)
            return undefined;
        return node.name.text;
    }
    return undefined;
}

/**
 * An Error that can be thrown when an unexpected node is encountered
 */
class UnexpectedNodeError extends EvaluationError {
    constructor({ node, typescript, message = `Unexpected Node: '${typescript.SyntaxKind[node.kind]}'` }) {
        super({ message, node });
    }
}

/**
 * An Error that can be thrown when an undefined leftValue is encountered
 */
class UndefinedLeftValueError extends EvaluationError {
    constructor({ node, message = `'No leftValue could be determined'` }) {
        super({ message, node });
    }
}

/**
 * Evaluates, or attempts to evaluate, a BinaryExpression
 */
function evaluateBinaryExpression(options) {
    const { node, environment, evaluate, logger, statementTraversalStack, reporting, typescript } = options;
    const leftValue = evaluate.expression(node.left, environment, statementTraversalStack);
    const rightValue = evaluate.expression(node.right, environment, statementTraversalStack);
    const leftIdentifier = getDotPathFromNode(Object.assign(Object.assign({}, options), { node: node.left }));
    const operator = node.operatorToken.kind;
    switch (operator) {
        case typescript.SyntaxKind.AmpersandToken: {
            return leftValue & rightValue;
        }
        case typescript.SyntaxKind.AmpersandAmpersandToken: {
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            return leftValue && rightValue;
        }
        case typescript.SyntaxKind.AmpersandEqualsToken:
        case typescript.SyntaxKind.CaretEqualsToken:
        case typescript.SyntaxKind.BarEqualsToken:
        case typescript.SyntaxKind.MinusEqualsToken:
        case typescript.SyntaxKind.PlusEqualsToken:
        case typescript.SyntaxKind.PercentEqualsToken:
        case typescript.SyntaxKind.SlashEqualsToken:
        case typescript.SyntaxKind.AsteriskEqualsToken:
        case typescript.SyntaxKind.AsteriskAsteriskEqualsToken:
        case typescript.SyntaxKind.LessThanLessThanEqualsToken:
        case typescript.SyntaxKind.GreaterThanGreaterThanEqualsToken:
        case typescript.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
        case typescript.SyntaxKind.QuestionQuestionEqualsToken:
        case typescript.SyntaxKind.BarBarEqualsToken:
        case typescript.SyntaxKind.AmpersandAmpersandEqualsToken: {
            // There's nothing in the engine restricting you from applying this kind of arithmetic operation on non-numeric data types
            let computedValue = leftValue;
            switch (operator) {
                case typescript.SyntaxKind.AmpersandEqualsToken:
                    computedValue &= rightValue;
                    break;
                case typescript.SyntaxKind.CaretEqualsToken:
                    computedValue ^= rightValue;
                    break;
                case typescript.SyntaxKind.BarEqualsToken:
                    computedValue |= rightValue;
                    break;
                case typescript.SyntaxKind.AsteriskEqualsToken:
                    computedValue *= rightValue;
                    break;
                case typescript.SyntaxKind.AsteriskAsteriskEqualsToken:
                    computedValue **= rightValue;
                    break;
                case typescript.SyntaxKind.LessThanLessThanEqualsToken:
                    computedValue <<= rightValue;
                    break;
                case typescript.SyntaxKind.GreaterThanGreaterThanEqualsToken:
                    computedValue >>= rightValue;
                    break;
                case typescript.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                    computedValue >>>= rightValue;
                    break;
                case typescript.SyntaxKind.MinusEqualsToken:
                    computedValue -= rightValue;
                    break;
                case typescript.SyntaxKind.PlusEqualsToken:
                    computedValue += rightValue;
                    break;
                case typescript.SyntaxKind.PercentEqualsToken:
                    computedValue %= rightValue;
                    break;
                case typescript.SyntaxKind.SlashEqualsToken:
                    computedValue /= rightValue;
                    break;
                case typescript.SyntaxKind.QuestionQuestionEqualsToken:
                    computedValue = leftValue == null ? rightValue : leftValue;
                    break;
                case typescript.SyntaxKind.BarBarEqualsToken:
                    if (!leftValue) {
                        computedValue = rightValue;
                    }
                    break;
                case typescript.SyntaxKind.AmpersandAmpersandEqualsToken:
                    if (leftValue) {
                        computedValue = rightValue;
                    }
                    break;
            }
            // Update to the left-value within the environment if it exists there and has been updated
            if (leftIdentifier != null) {
                setInLexicalEnvironment({ env: environment, path: leftIdentifier, value: computedValue, reporting, node });
            }
            // Return the computed value
            return computedValue;
        }
        case typescript.SyntaxKind.AsteriskToken: {
            return leftValue * rightValue;
        }
        case typescript.SyntaxKind.AsteriskAsteriskToken: {
            return leftValue ** rightValue;
        }
        case typescript.SyntaxKind.BarToken: {
            return leftValue | rightValue;
        }
        case typescript.SyntaxKind.BarBarToken: {
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            return leftValue || rightValue;
        }
        case typescript.SyntaxKind.CaretToken: {
            return leftValue ^ rightValue;
        }
        case typescript.SyntaxKind.CommaToken: {
            return rightValue;
        }
        case typescript.SyntaxKind.MinusToken:
            return leftValue - rightValue;
        case typescript.SyntaxKind.PlusToken:
            logger.logResult(leftValue + rightValue, "BinaryExpression (PlusToken)");
            return leftValue + rightValue;
        case typescript.SyntaxKind.PercentToken:
            return leftValue % rightValue;
        case typescript.SyntaxKind.SlashToken:
            return leftValue / rightValue;
        case typescript.SyntaxKind.EqualsToken: {
            // Update to the left-value within the environment if it exists there and has been updated
            if (leftIdentifier != null) {
                setInLexicalEnvironment({ env: environment, path: leftIdentifier, value: rightValue, reporting, node });
                logger.logBinding(leftIdentifier, rightValue, "Assignment");
            }
            else {
                throw new UndefinedLeftValueError({ node: node.left });
            }
            // The return value of an assignment is always the assigned value
            return rightValue;
        }
        case typescript.SyntaxKind.EqualsEqualsToken: {
            // eslint-disable-next-line eqeqeq
            return leftValue == rightValue;
        }
        case typescript.SyntaxKind.EqualsEqualsEqualsToken: {
            return leftValue === rightValue;
        }
        case typescript.SyntaxKind.ExclamationEqualsToken: {
            // eslint-disable-next-line eqeqeq
            return leftValue != rightValue;
        }
        case typescript.SyntaxKind.ExclamationEqualsEqualsToken: {
            return leftValue !== rightValue;
        }
        case typescript.SyntaxKind.GreaterThanToken:
            return leftValue > rightValue;
        case typescript.SyntaxKind.GreaterThanEqualsToken:
            return leftValue >= rightValue;
        case typescript.SyntaxKind.LessThanToken:
            return leftValue < rightValue;
        case typescript.SyntaxKind.LessThanEqualsToken:
            return leftValue <= rightValue;
        case typescript.SyntaxKind.InKeyword: {
            return leftValue in rightValue;
        }
        // Nullish coalescing (A ?? B)
        case typescript.SyntaxKind.QuestionQuestionToken:
            return leftValue != null ? leftValue : rightValue;
        case typescript.SyntaxKind.InstanceOfKeyword: {
            return leftValue instanceof rightValue;
        }
    }
    // Throw if the operator couldn't be handled
    throw new UnexpectedNodeError({ node: node.operatorToken, typescript });
}

// tslint:disable:no-any
const LAZY_CALL_FLAG = "___lazyCallFlag";
/**
 * Returns true if the given literal is a lazy call
 *
 * @param literal
 * @return
 */
function isLazyCall(literal) {
    return literal != null && typeof literal === "object" && LAZY_CALL_FLAG in literal;
}
/**
 * Stringifies the given literal
 *
 * @param literal
 * @return
 */
function stringifyLiteral(literal) {
    if (literal === undefined)
        return "undefined";
    else if (literal === null)
        return "null";
    else if (typeof literal === "string")
        return `"${literal}"`;
    return literal.toString();
}

/**
 * An Error that can be thrown when a value is attempted to be called, but isn't callable
 */
class NotCallableError extends EvaluationError {
    constructor({ value, node, message = `${stringifyLiteral(value)} is not a function'` }) {
        super({ message, node });
        this.value = value;
    }
}

/**
 * Returns true if the given expression contains a 'super' keyword
 */
function expressionContainsSuperKeyword(expression, typescript) {
    if (isSuperExpression(expression, typescript))
        return true;
    else if (typescript.isPropertyAccessExpression(expression)) {
        return expressionContainsSuperKeyword(expression.expression, typescript) || expressionContainsSuperKeyword(expression.name, typescript);
    }
    else if (typescript.isElementAccessExpression(expression)) {
        return expressionContainsSuperKeyword(expression.expression, typescript) || expressionContainsSuperKeyword(expression.argumentExpression, typescript);
    }
    else if (typescript.isParenthesizedExpression(expression))
        return expressionContainsSuperKeyword(expression.expression, typescript);
    else if (typescript.isAsExpression(expression))
        return expressionContainsSuperKeyword(expression.expression, typescript);
    else if (typescript.isTypeAssertion(expression))
        return expressionContainsSuperKeyword(expression.expression, typescript);
    else {
        return false;
    }
}

/**
 * Evaluates, or attempts to evaluate, a CallExpression
 */
function evaluateCallExpression({ node, environment, evaluate, statementTraversalStack, typescript, logger }) {
    const evaluatedArgs = [];
    for (let i = 0; i < node.arguments.length; i++) {
        evaluatedArgs[i] = evaluate.expression(node.arguments[i], environment, statementTraversalStack);
    }
    // Evaluate the expression
    const expressionResult = evaluate.expression(node.expression, environment, statementTraversalStack);
    if (isLazyCall(expressionResult)) {
        const currentThisBinding = expressionContainsSuperKeyword(node.expression, typescript) ? getFromLexicalEnvironment(node, environment, THIS_SYMBOL) : undefined;
        const value = expressionResult.invoke(currentThisBinding != null ? currentThisBinding.literal : undefined, ...evaluatedArgs);
        logger.logResult(value, "CallExpression");
        return value;
    }
    // Otherwise, assume that the expression still needs calling
    else {
        // Unless optional chaining is being used, throw a NotCallableError
        if (node.questionDotToken == null && typeof expressionResult !== "function") {
            throw new NotCallableError({ value: expressionResult, node: node.expression });
        }
        const value = typeof expressionResult !== "function" ? undefined : expressionResult(...evaluatedArgs);
        logger.logResult(value, "CallExpression");
        return value;
    }
}

/**
 * Evaluates, or attempts to evaluate, a ParenthesizedExpression
 */
function evaluateParenthesizedExpression({ node, environment, evaluate, statementTraversalStack }) {
    return evaluate.expression(node.expression, environment, statementTraversalStack);
}

/**
 * Clones the given LexicalEnvironment
 */
function cloneLexicalEnvironment(environment) {
    return {
        parentEnv: environment,
        env: {}
    };
}

/**
 * Returns true if the given Node has the given kind of Modifier
 */
function hasModifier(node, modifier) {
    const modifiers = Array.isArray(node) ? node : node.modifiers;
    return modifiers != null && modifiers.some(m => m.kind === modifier);
}

/**
 * Evaluates, or attempts to evaluate, a NodeArray of ParameterDeclarations
 */
function evaluateParameterDeclarations({ node, evaluate, environment, statementTraversalStack, typescript }, boundArguments, context) {
    // 'this' is a special parameter which is removed from the emitted results
    const parameters = node.filter(param => !(typescript.isIdentifier(param.name) && param.name.text === "this"));
    for (let i = 0; i < parameters.length; i++) {
        const parameter = parameters[i];
        // It it is a spread element, it should receive all arguments from the current index.
        if (parameter.dotDotDotToken != null) {
            evaluate.nodeWithArgument(parameter, environment, boundArguments.slice(i), statementTraversalStack);
            // Spread elements must always be the last parameter
            break;
        }
        else {
            evaluate.nodeWithArgument(parameter, environment, boundArguments[i], statementTraversalStack);
            // If a context is given, and if a [public|protected|private] keyword is in front of the parameter, the initialized value should be
            // set on the context as an instance property
            if (context != null &&
                typescript.isIdentifier(parameter.name) &&
                (hasModifier(parameter, typescript.SyntaxKind.PublicKeyword) ||
                    hasModifier(parameter, typescript.SyntaxKind.ProtectedKeyword) ||
                    hasModifier(parameter, typescript.SyntaxKind.PrivateKeyword))) {
                const value = getFromLexicalEnvironment(parameter, environment, parameter.name.text);
                if (value != null) {
                    context[parameter.name.text] = value.literal;
                }
            }
        }
    }
}

/**
 * Evaluates, or attempts to evaluate, an ArrowFunction
 */
function evaluateArrowFunctionExpression(options) {
    const { node, environment, evaluate, stack, statementTraversalStack, reporting, typescript } = options;
    const arrowFunctionExpression = hasModifier(node, typescript.SyntaxKind.AsyncKeyword)
        ? async (...args) => {
            // Prepare a lexical environment for the function context
            const localLexicalEnvironment = cloneLexicalEnvironment(environment);
            // Define a new binding for a return symbol within the environment
            setInLexicalEnvironment({ env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node });
            // Define a new binding for the arguments given to the function
            // eslint-disable-next-line prefer-rest-params
            setInLexicalEnvironment({ env: localLexicalEnvironment, path: "arguments", value: arguments, newBinding: true, reporting, node });
            // Evaluate the parameters based on the given arguments
            evaluateParameterDeclarations(Object.assign(Object.assign({}, options), { node: node.parameters, environment: localLexicalEnvironment }), args);
            // If the body is a block, evaluate it as a statement
            if (typescript.isBlock(node.body)) {
                evaluate.statement(node.body, localLexicalEnvironment);
                // If a 'return' has occurred within the block, pop the Stack and return that value
                if (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {
                    return stack.pop();
                }
                // Otherwise, return 'undefined'. Nothing is returned from the function
                else
                    return undefined;
            }
            // Otherwise, the body is itself an expression
            else {
                return evaluate.expression(node.body, localLexicalEnvironment, statementTraversalStack);
            }
        }
        : (...args) => {
            // Prepare a lexical environment for the function context
            const localLexicalEnvironment = cloneLexicalEnvironment(environment);
            // Define a new binding for a return symbol within the environment
            setInLexicalEnvironment({ env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node });
            // Define a new binding for the arguments given to the function
            // eslint-disable-next-line prefer-rest-params
            setInLexicalEnvironment({ env: localLexicalEnvironment, path: "arguments", value: arguments, newBinding: true, reporting, node });
            // Evaluate the parameters based on the given arguments
            evaluateParameterDeclarations(Object.assign(Object.assign({}, options), { node: node.parameters, environment: localLexicalEnvironment }), args);
            // If the body is a block, evaluate it as a statement
            if (typescript.isBlock(node.body)) {
                evaluate.statement(node.body, localLexicalEnvironment);
                // If a 'return' has occurred within the block, pop the Stack and return that value
                if (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {
                    return stack.pop();
                }
                // Otherwise, return 'undefined'. Nothing is returned from the function
                else
                    return undefined;
            }
            // Otherwise, the body is itself an expression
            else {
                return evaluate.expression(node.body, localLexicalEnvironment, statementTraversalStack);
            }
        };
    arrowFunctionExpression.toString = () => `[Function: anonymous]`;
    // Make sure to use the Function that is contained within the Realm. Otherwise, 'instanceof' checks may fail
    // since this particular function comes from the executing context.
    Object.setPrototypeOf(arrowFunctionExpression, getFromLexicalEnvironment(node, environment, "Function").literal);
    return arrowFunctionExpression;
}

/**
 * Evaluates, or attempts to evaluate, a StringLiteralLike
 */
function evaluateStringLiteral({ node }) {
    return node.text;
}

/**
 * Evaluates, or attempts to evaluate, a NumericLiteral
 */
function evaluateNumericLiteral({ node }) {
    return Number(node.text);
}

/**
 * Evaluates, or attempts to evaluate, a BooleanLiteral
 */
function evaluateBooleanLiteral({ node, typescript }) {
    return node.kind === typescript.SyntaxKind.TrueKeyword;
}

/**
 * Evaluates, or attempts to evaluate, a RegularExpressionLiteral
 */
function evaluateRegularExpressionLiteral({ node, environment }) {
    const functionCtor = getFromLexicalEnvironment(node, environment, "Function").literal;
    return new functionCtor(`return ${node.text}`)();
}

/**
 * Evaluates, or attempts to evaluate, a ObjectLiteralExpression
 */
function evaluateObjectLiteralExpression({ node, evaluate, environment, reporting, statementTraversalStack }) {
    // Create a new ObjectLiteral based on the Object implementation from the Realm since this must not be the same as in the parent executing context
    // Otherwise, instanceof checks would fail
    const objectCtor = getFromLexicalEnvironment(node, environment, "Object").literal;
    const value = objectCtor.create(objectCtor.prototype);
    // Mark the object as the 'this' value of the scope
    setInLexicalEnvironment({ env: environment, path: THIS_SYMBOL, value, newBinding: true, reporting, node });
    for (const property of node.properties) {
        evaluate.nodeWithArgument(property, environment, value, statementTraversalStack);
    }
    return value;
}

/**
 * Returns true if the given item is an Iterable
 *
 * @param item
 * @return
 */
function isIterable(item) {
    return item != null && item[Symbol.iterator] != null;
}

/**
 * Evaluates, or attempts to evaluate, a ArrayLiteralExpression
 */
function evaluateArrayLiteralExpression({ node, environment, evaluate, typescript, statementTraversalStack }) {
    // Get the Array constructor from the realm - not that of the executing context. Otherwise, instanceof checks would fail
    const arrayCtor = getFromLexicalEnvironment(node, environment, "Array").literal;
    const value = arrayCtor.of();
    for (const element of node.elements) {
        const nextValue = evaluate.expression(element, environment, statementTraversalStack);
        if (typescript.isSpreadElement(element) && isIterable(nextValue)) {
            value.push(...nextValue);
        }
        else {
            value.push(nextValue);
        }
    }
    return value;
}

/**
 * An Error that can be thrown when an undefined identifier is encountered
 */
class UndefinedIdentifierError extends EvaluationError {
    constructor({ node, message = `'${node.text}' is not defined'` }) {
        super({ message, node });
    }
}

/**
 * Returns true if the given VariableDeclarationList is declared with a 'var' keyword
 */
function isVarDeclaration(declarationList, typescript) {
    return declarationList.flags !== typescript.NodeFlags.Const && declarationList.flags !== typescript.NodeFlags.Let;
}

/**
 * Finds the nearest parent node of the given kind from the given Node
 */
function findNearestParentNodeOfKind(from, kind, typescript) {
    let currentParent = from;
    while (true) {
        currentParent = currentParent.parent;
        if (currentParent == null)
            return undefined;
        if (currentParent.kind === kind) {
            const combinedNodeFlags = typescript.getCombinedNodeFlags(currentParent);
            const isNamespace = (combinedNodeFlags & typescript.NodeFlags.Namespace) !== 0 || (combinedNodeFlags & typescript.NodeFlags.NestedNamespace) !== 0;
            if (!isNamespace)
                return currentParent;
        }
        if (typescript.isSourceFile(currentParent))
            return undefined;
    }
}

/**
 * An Error that can be thrown when a moduleSpecifier couldn't be resolved
 */
class ModuleNotFoundError extends EvaluationError {
    constructor({ path, node, message = `Module '${path}' could not be resolved'` }) {
        super({ message, node });
        this.path = path;
    }
}

/**
 * Gets the name of the given declaration
 */
function getDeclarationName({ node, evaluate, environment, typescript, statementTraversalStack }) {
    var _a;
    const name = typescript.getNameOfDeclaration(node);
    if (name == null)
        return undefined;
    if (typescript.isIdentifier(name)) {
        return name.text;
    }
    else if ((_a = typescript.isPrivateIdentifier) === null || _a === void 0 ? void 0 : _a.call(typescript, name)) {
        return name.text;
    }
    else if (typescript.isStringLiteralLike(name)) {
        return name.text;
    }
    else if (typescript.isNumericLiteral(name)) {
        return Number(name.text);
    }
    else if (typescript.isComputedPropertyName(name)) {
        return evaluate.expression(name.expression, environment, statementTraversalStack);
    }
    else {
        throw new UnexpectedNodeError({ node: name, typescript });
    }
}

/**
 * Gets an implementation for the given declaration that lives within a declaration file
 */
function getImplementationForDeclarationWithinDeclarationFile(options) {
    var _a;
    const { node, typescript } = options;
    const name = getDeclarationName(options);
    if (name == null) {
        throw new UnexpectedNodeError({ node, typescript });
    }
    // First see if it lives within the lexical environment
    const matchInLexicalEnvironment = getFromLexicalEnvironment(node, options.environment, name);
    // If so, return it
    if (matchInLexicalEnvironment != null && matchInLexicalEnvironment.literal != null) {
        return matchInLexicalEnvironment.literal;
    }
    // Otherwise, expect it to be something that is require'd on demand
    const require = getFromLexicalEnvironment(node, options.environment, "require").literal;
    const moduleDeclaration = typescript.isModuleDeclaration(node)
        ? node
        : findNearestParentNodeOfKind(node, typescript.SyntaxKind.ModuleDeclaration, typescript);
    if (moduleDeclaration == null) {
        throw new UnexpectedNodeError({ node, typescript });
    }
    try {
        // eslint-disable-next-line @typescript-eslint/no-require-imports,@typescript-eslint/no-var-requires
        const module = require(moduleDeclaration.name.text);
        return typescript.isModuleDeclaration(node) ? module : (_a = module[name]) !== null && _a !== void 0 ? _a : module;
    }
    catch (ex) {
        if (ex instanceof EvaluationError)
            throw ex;
        else
            throw new ModuleNotFoundError({ node: moduleDeclaration, path: moduleDeclaration.name.text });
    }
}

/**
 * Evaluates, or attempts to evaluate, an Identifier or a PrivateIdentifier
 */
function evaluateIdentifier(options) {
    const { node, environment, typeChecker, evaluate, stack, logger, reporting, typescript, statementTraversalStack } = options;
    // Otherwise, try to resolve it. Maybe it exists in the environment already?
    const environmentMatch = getFromLexicalEnvironment(node, environment, node.text);
    if (environmentMatch != null) {
        logger.logBinding(node.text, environmentMatch.literal, "Lexical Environment match");
        // Return the existing evaluated value from the environment
        return environmentMatch.literal;
    }
    // Try to get a symbol for whatever the identifier points to and take its value declaration.
    // It may not have a symbol, for example if it is an inlined expression such as an initializer or a Block
    const symbol = typeChecker.getSymbolAtLocation(node);
    let valueDeclaration = symbol == null ? undefined : symbol.valueDeclaration;
    if (symbol != null && valueDeclaration == null) {
        try {
            // The symbol may be aliasing another one - which may have a value declaration
            const aliasedSymbol = typeChecker.getAliasedSymbol(symbol);
            valueDeclaration = aliasedSymbol.valueDeclaration;
        }
        catch (_a) {
            // OK, it didn't alias anything
        }
    }
    // If it has a value declaration, go forward with that one
    if (valueDeclaration != null) {
        if (valueDeclaration.getSourceFile().isDeclarationFile) {
            const implementation = getImplementationForDeclarationWithinDeclarationFile(Object.assign(Object.assign({}, options), { node: valueDeclaration }));
            // Bind the value placed on the top of the stack to the local environment
            setInLexicalEnvironment({ env: environment, path: node.text, value: implementation, reporting, node: valueDeclaration });
            logger.logBinding(node.text, implementation, `Discovered declaration value${valueDeclaration.getSourceFile() === node.getSourceFile() ? "" : ` (imported into '${node.getSourceFile().fileName}' from '${valueDeclaration.getSourceFile().fileName}')`}`);
            return implementation;
        }
        // If the value is a variable declaration and is located *after* the current node within the SourceFile
        // It is potentially a SyntaxError unless it is hoisted (if the 'var' keyword is being used) in which case the variable is defined, but initialized to 'undefined'
        if (typescript.isVariableDeclaration(valueDeclaration) && valueDeclaration.getSourceFile().fileName === node.getSourceFile().fileName && valueDeclaration.pos > node.pos) {
            // The 'var' keyword declares a variable that is defined, but which rvalue is still undefined
            if (typescript.isVariableDeclarationList(valueDeclaration.parent) && isVarDeclaration(valueDeclaration.parent, typescript)) {
                const returnValue = undefined;
                setInLexicalEnvironment({ env: environment, path: node.text, value: returnValue, newBinding: true, reporting, node: valueDeclaration });
                logger.logBinding(node.text, returnValue, "Hoisted var declaration");
                return returnValue;
            }
            // In all other cases, both the identifier and the rvalue is still undefined
            else {
                throw new UndefinedIdentifierError({ node });
            }
        }
        evaluate.declaration(valueDeclaration, environment, statementTraversalStack);
        const stackValue = stack.pop();
        // Bind the value placed on the top of the stack to the local environment
        setInLexicalEnvironment({ env: environment, path: node.text, value: stackValue, reporting, node: valueDeclaration });
        logger.logBinding(node.text, stackValue, `Discovered declaration value${valueDeclaration.getSourceFile() === node.getSourceFile() ? "" : ` (imported into '${node.getSourceFile().fileName}' from '${valueDeclaration.getSourceFile().fileName}')`}`);
        return stackValue;
    }
    // Otherwise throw. The identifier is unknown
    throw new UndefinedIdentifierError({ node });
}

/**
 * Evaluates, or attempts to evaluate, a Block
 */
function evaluateBlock({ node, environment, typescript, evaluate }) {
    // Prepare a lexical environment for the Block context
    const localLexicalEnvironment = cloneLexicalEnvironment(environment);
    for (let i = 0; i < node.statements.length; i++) {
        const statement = node.statements[i];
        // Don't execute 'super()' within Constructor Blocks since this is handled in another level
        if (typescript.isConstructorDeclaration(node.parent) &&
            i === 0 &&
            typescript.isExpressionStatement(statement) &&
            typescript.isCallExpression(statement.expression) &&
            isSuperExpression(statement.expression.expression, typescript)) {
            continue;
        }
        evaluate.statement(statement, localLexicalEnvironment);
        // Check if a 'break', 'continue', or 'return' statement has been encountered, break the block
        if (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, BREAK_SYMBOL, CONTINUE_SYMBOL, RETURN_SYMBOL)) {
            break;
        }
    }
}

/**
 * Evaluates, or attempts to evaluate, a ReturnStatement
 */
function evaluateReturnStatement({ node, environment, evaluate, stack, reporting, statementTraversalStack }) {
    setInLexicalEnvironment({ env: environment, path: RETURN_SYMBOL, value: true, reporting, node });
    // If it is a simple 'return', return undefined
    if (node.expression == null) {
        stack.push(undefined);
    }
    else {
        stack.push(evaluate.expression(node.expression, environment, statementTraversalStack));
    }
}

/**
 * Evaluates, or attempts to evaluate, a VariableDeclarationList
 */
function evaluateVariableDeclarationList({ node, evaluate, environment, statementTraversalStack }) {
    for (const declaration of node.declarations) {
        evaluate.declaration(declaration, environment, statementTraversalStack);
    }
}

/**
 * Evaluates, or attempts to evaluate, a VariableStatement
 */
function evaluateVariableStatement(_a) {
    var { node } = _a, rest = __rest(_a, ["node"]);
    evaluateVariableDeclarationList(Object.assign({ node: node.declarationList }, rest));
}

/**
 * Evaluates, or attempts to evaluate, a PrefixUnaryExpression
 */
function evaluatePrefixUnaryExpression({ node, environment, evaluate, reporting, typescript, statementTraversalStack }) {
    var _a, _b;
    const operandValue = evaluate.expression(node.operand, environment, statementTraversalStack);
    switch (node.operator) {
        case typescript.SyntaxKind.PlusToken: {
            return +operandValue;
        }
        case typescript.SyntaxKind.MinusToken: {
            return -operandValue;
        }
        case typescript.SyntaxKind.TildeToken: {
            return ~operandValue;
        }
        case typescript.SyntaxKind.ExclamationToken: {
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            return !operandValue;
        }
        case typescript.SyntaxKind.PlusPlusToken: {
            // If the Operand isn't an identifier, this will be a SyntaxError
            if (!typescript.isIdentifier(node.operand) && !((_a = typescript.isPrivateIdentifier) === null || _a === void 0 ? void 0 : _a.call(typescript, node.operand))) {
                throw new UnexpectedNodeError({ node: node.operand, typescript });
            }
            // Find the value associated with the identifier within the environment.
            const dict = getRelevantDictFromLexicalEnvironment(environment, node.operand.text);
            const value = ++dict[node.operand.text];
            // Inform reporting hooks if any is given
            if (reporting.reportBindings != null) {
                reporting.reportBindings({ path: node.operand.text, value, node });
            }
            return value;
        }
        case typescript.SyntaxKind.MinusMinusToken: {
            // If the Operand isn't an identifier, this will be a SyntaxError
            if (!typescript.isIdentifier(node.operand) && !((_b = typescript.isPrivateIdentifier) === null || _b === void 0 ? void 0 : _b.call(typescript, node.operand))) {
                throw new UnexpectedNodeError({ node: node.operand, typescript });
            }
            // Find the value associated with the identifier within the environment.
            const dict = getRelevantDictFromLexicalEnvironment(environment, node.operand.text);
            const value = --dict[node.operand.text];
            // Inform reporting hooks if any is given
            if (reporting.reportBindings != null) {
                reporting.reportBindings({ path: node.operand.text, value, node });
            }
            return value;
        }
    }
}

/**
 * Evaluates, or attempts to evaluate, a PropertyAccessExpression
 */
function evaluatePropertyAccessExpression({ node, environment, evaluate, typescript, statementTraversalStack }) {
    const expressionResult = evaluate.expression(node.expression, environment, statementTraversalStack);
    const match = node.questionDotToken != null && expressionResult == null
        ? // If optional chaining are being used and the expressionResult is undefined or null, assign undefined to 'match'
            undefined
        : expressionResult[node.name.text];
    // If it is a function, wrap it in a lazy call to preserve implicit 'this' bindings. This is to avoid losing the 'this' binding or having to
    // explicitly bind a 'this' value
    if (typeof match === "function" && statementTraversalStack.includes(typescript.SyntaxKind.CallExpression)) {
        return {
            [LAZY_CALL_FLAG]: 0 /* CALL */,
            invoke: (overriddenThis, ...args) => overriddenThis != null && !isBindCallApply(match, environment)
                ? // eslint-disable-next-line @typescript-eslint/ban-types
                    expressionResult[node.name.text].call(overriddenThis, ...args)
                : expressionResult[node.name.text](...args)
        };
    }
    else
        return match;
}

/**
 * Evaluates, or attempts to evaluate, a ElementAccessExpression
 */
function evaluateElementAccessExpression({ node, environment, evaluate, statementTraversalStack, typescript }) {
    const expressionResult = evaluate.expression(node.expression, environment, statementTraversalStack);
    const argumentExpressionResult = evaluate.expression(node.argumentExpression, environment, statementTraversalStack);
    const match = node.questionDotToken != null && expressionResult == null
        ? // If optional chaining are being used and the expressionResult is undefined or null, assign undefined to 'match'
            undefined
        : expressionResult[argumentExpressionResult];
    // If it is a function, wrap it in a lazy call to preserve implicit this bindings. This is to avoid losing the this binding or having to
    // explicitly bind a 'this' value
    if (typeof match === "function" && statementTraversalStack.includes(typescript.SyntaxKind.CallExpression)) {
        return {
            [LAZY_CALL_FLAG]: 0 /* CALL */,
            invoke: (overriddenThis, ...args) => overriddenThis != null && !isBindCallApply(match, environment)
                ? // eslint-disable-next-line @typescript-eslint/ban-types
                    expressionResult[argumentExpressionResult].call(overriddenThis, ...args)
                : expressionResult[argumentExpressionResult](...args)
        };
    }
    else
        return match;
}

/**
 * Evaluates, or attempts to evaluate, a ComputedPropertyName
 */
function evaluateComputedPropertyName({ node, environment, evaluate, statementTraversalStack }) {
    return evaluate.expression(node.expression, environment, statementTraversalStack);
}

/**
 * Evaluates, or attempts to evaluate, a FunctionDeclaration
 */
function evaluateFunctionDeclaration(options) {
    const { node, environment, evaluate, stack, reporting, typescript } = options;
    const nameResult = node.name == null ? undefined : node.name.text;
    const _functionDeclaration = hasModifier(node, typescript.SyntaxKind.AsyncKeyword)
        ? async function functionDeclaration(...args) {
            // Prepare a lexical environment for the function context
            const localLexicalEnvironment = cloneLexicalEnvironment(environment);
            // Define a new binding for a return symbol within the environment
            setInLexicalEnvironment({ env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node });
            // Define a new binding for the arguments given to the function
            // eslint-disable-next-line prefer-rest-params
            setInLexicalEnvironment({ env: localLexicalEnvironment, path: "arguments", value: arguments, newBinding: true, reporting, node });
            if (this != null) {
                setInLexicalEnvironment({ env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node });
            }
            // Evaluate the parameters based on the given arguments
            evaluateParameterDeclarations(Object.assign(Object.assign({}, options), { node: node.parameters, environment: localLexicalEnvironment }), args);
            const sourceFile = node.getSourceFile();
            if (nameResult != null && sourceFile.isDeclarationFile) {
                const implementation = getImplementationForDeclarationWithinDeclarationFile(options);
                return implementation(...args);
            }
            // If the body is a block, evaluate it as a statement
            if (node.body == null)
                return;
            evaluate.statement(node.body, localLexicalEnvironment);
            // If a 'return' has occurred within the block, pop the Stack and return that value
            if (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {
                return stack.pop();
            }
            // Otherwise, return 'undefined'. Nothing is returned from the function
            else {
                return undefined;
            }
        }
        : function functionDeclaration(...args) {
            // Prepare a lexical environment for the function context
            const localLexicalEnvironment = cloneLexicalEnvironment(environment);
            // Define a new binding for a return symbol within t